// Code generated by gtrace. DO NOT EDIT.

package trace

import (
	"context"
)

// retryComposeOptions is a holder of options
type retryComposeOptions struct {
	panicCallback func(e interface{})
}

// RetryOption specified Retry compose option
// Internals: https://github.com/ydb-platform/ydb-go-sdk/blob/master/VERSIONING.md#internals
type RetryComposeOption func(o *retryComposeOptions)

// WithRetryPanicCallback specified behavior on panic
// Internals: https://github.com/ydb-platform/ydb-go-sdk/blob/master/VERSIONING.md#internals
func WithRetryPanicCallback(cb func(e interface{})) RetryComposeOption {
	return func(o *retryComposeOptions) {
		o.panicCallback = cb
	}
}

// Compose returns a new Retry which has functional fields composed both from t and x.
// Internals: https://github.com/ydb-platform/ydb-go-sdk/blob/master/VERSIONING.md#internals
func (t *Retry) Compose(x *Retry, opts ...RetryComposeOption) *Retry {
	if t == nil {
		return x
	}
	var ret Retry
	options := retryComposeOptions{}
	for _, opt := range opts {
		if opt != nil {
			opt(&options)
		}
	}
	{
		h1 := t.OnRetry
		h2 := x.OnRetry
		ret.OnRetry = func(r RetryLoopStartInfo) func(RetryLoopDoneInfo) {
			if options.panicCallback != nil {
				defer func() {
					if e := recover(); e != nil {
						options.panicCallback(e)
					}
				}()
			}
			var r1, r2 func(RetryLoopDoneInfo)
			if h1 != nil {
				r1 = h1(r)
			}
			if h2 != nil {
				r2 = h2(r)
			}
			return func(r RetryLoopDoneInfo) {
				if options.panicCallback != nil {
					defer func() {
						if e := recover(); e != nil {
							options.panicCallback(e)
						}
					}()
				}
				if r1 != nil {
					r1(r)
				}
				if r2 != nil {
					r2(r)
				}
			}
		}
	}
	return &ret
}
func (t *Retry) onRetry(r RetryLoopStartInfo) func(RetryLoopDoneInfo) {
	fn := t.OnRetry
	if fn == nil {
		return func(RetryLoopDoneInfo) {
			return
		}
	}
	res := fn(r)
	if res == nil {
		return func(RetryLoopDoneInfo) {
			return
		}
	}
	return res
}
// Internals: https://github.com/ydb-platform/ydb-go-sdk/blob/master/VERSIONING.md#internals
func RetryOnRetry(t *Retry, c *context.Context, call call, label string, idempotent bool, nestedCall bool) func(attempts int, _ error) {
	var p RetryLoopStartInfo
	p.Context = c
	p.Call = call
	p.Label = label
	p.Idempotent = idempotent
	p.NestedCall = nestedCall
	res := t.onRetry(p)
	return func(attempts int, e error) {
		var p RetryLoopDoneInfo
		p.Attempts = attempts
		p.Error = e
		res(p)
	}
}
