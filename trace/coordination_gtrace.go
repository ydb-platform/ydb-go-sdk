// Code generated by gtrace. DO NOT EDIT.

package trace

import (
	"context"
	"time"

	"github.com/ydb-platform/ydb-go-genproto/protos/Ydb_Coordination"
)

// coordinationComposeOptions is a holder of options
type coordinationComposeOptions struct {
	panicCallback func(e interface{})
}

// CoordinationOption specified Coordination compose option
type CoordinationComposeOption func(o *coordinationComposeOptions)

// WithCoordinationPanicCallback specified behavior on panic
func WithCoordinationPanicCallback(cb func(e interface{})) CoordinationComposeOption {
	return func(o *coordinationComposeOptions) {
		o.panicCallback = cb
	}
}

// Compose returns a new Coordination which has functional fields composed both from t and x.
func (t *Coordination) Compose(x *Coordination, opts ...CoordinationComposeOption) *Coordination {
	var ret Coordination
	options := coordinationComposeOptions{}
	for _, opt := range opts {
		if opt != nil {
			opt(&options)
		}
	}
	{
		h1 := t.OnNew
		h2 := x.OnNew
		ret.OnNew = func(c CoordinationNewStartInfo) func(CoordinationNewDoneInfo) {
			if options.panicCallback != nil {
				defer func() {
					if e := recover(); e != nil {
						options.panicCallback(e)
					}
				}()
			}
			var r, r1 func(CoordinationNewDoneInfo)
			if h1 != nil {
				r = h1(c)
			}
			if h2 != nil {
				r1 = h2(c)
			}
			return func(c CoordinationNewDoneInfo) {
				if options.panicCallback != nil {
					defer func() {
						if e := recover(); e != nil {
							options.panicCallback(e)
						}
					}()
				}
				if r != nil {
					r(c)
				}
				if r1 != nil {
					r1(c)
				}
			}
		}
	}
	{
		h1 := t.OnCreateNode
		h2 := x.OnCreateNode
		ret.OnCreateNode = func(c CoordinationCreateNodeStartInfo) func(CoordinationCreateNodeDoneInfo) {
			if options.panicCallback != nil {
				defer func() {
					if e := recover(); e != nil {
						options.panicCallback(e)
					}
				}()
			}
			var r, r1 func(CoordinationCreateNodeDoneInfo)
			if h1 != nil {
				r = h1(c)
			}
			if h2 != nil {
				r1 = h2(c)
			}
			return func(c CoordinationCreateNodeDoneInfo) {
				if options.panicCallback != nil {
					defer func() {
						if e := recover(); e != nil {
							options.panicCallback(e)
						}
					}()
				}
				if r != nil {
					r(c)
				}
				if r1 != nil {
					r1(c)
				}
			}
		}
	}
	{
		h1 := t.OnStreamNew
		h2 := x.OnStreamNew
		ret.OnStreamNew = func(c CoordinationStreamNewStartInfo) func(CoordinationStreamNewDoneInfo) {
			if options.panicCallback != nil {
				defer func() {
					if e := recover(); e != nil {
						options.panicCallback(e)
					}
				}()
			}
			var r, r1 func(CoordinationStreamNewDoneInfo)
			if h1 != nil {
				r = h1(c)
			}
			if h2 != nil {
				r1 = h2(c)
			}
			return func(c CoordinationStreamNewDoneInfo) {
				if options.panicCallback != nil {
					defer func() {
						if e := recover(); e != nil {
							options.panicCallback(e)
						}
					}()
				}
				if r != nil {
					r(c)
				}
				if r1 != nil {
					r1(c)
				}
			}
		}
	}
	{
		h1 := t.OnSessionStarted
		h2 := x.OnSessionStarted
		ret.OnSessionStarted = func(c CoordinationSessionStartedInfo) {
			if options.panicCallback != nil {
				defer func() {
					if e := recover(); e != nil {
						options.panicCallback(e)
					}
				}()
			}
			if h1 != nil {
				h1(c)
			}
			if h2 != nil {
				h2(c)
			}
		}
	}
	{
		h1 := t.OnSessionStartTimeout
		h2 := x.OnSessionStartTimeout
		ret.OnSessionStartTimeout = func(c CoordinationSessionStartTimeoutInfo) {
			if options.panicCallback != nil {
				defer func() {
					if e := recover(); e != nil {
						options.panicCallback(e)
					}
				}()
			}
			if h1 != nil {
				h1(c)
			}
			if h2 != nil {
				h2(c)
			}
		}
	}
	{
		h1 := t.OnSessionKeepAliveTimeout
		h2 := x.OnSessionKeepAliveTimeout
		ret.OnSessionKeepAliveTimeout = func(c CoordinationSessionKeepAliveTimeoutInfo) {
			if options.panicCallback != nil {
				defer func() {
					if e := recover(); e != nil {
						options.panicCallback(e)
					}
				}()
			}
			if h1 != nil {
				h1(c)
			}
			if h2 != nil {
				h2(c)
			}
		}
	}
	{
		h1 := t.OnSessionStopped
		h2 := x.OnSessionStopped
		ret.OnSessionStopped = func(c CoordinationSessionStoppedInfo) {
			if options.panicCallback != nil {
				defer func() {
					if e := recover(); e != nil {
						options.panicCallback(e)
					}
				}()
			}
			if h1 != nil {
				h1(c)
			}
			if h2 != nil {
				h2(c)
			}
		}
	}
	{
		h1 := t.OnSessionStopTimeout
		h2 := x.OnSessionStopTimeout
		ret.OnSessionStopTimeout = func(c CoordinationSessionStopTimeoutInfo) {
			if options.panicCallback != nil {
				defer func() {
					if e := recover(); e != nil {
						options.panicCallback(e)
					}
				}()
			}
			if h1 != nil {
				h1(c)
			}
			if h2 != nil {
				h2(c)
			}
		}
	}
	{
		h1 := t.OnSessionClientTimeout
		h2 := x.OnSessionClientTimeout
		ret.OnSessionClientTimeout = func(c CoordinationSessionClientTimeoutInfo) {
			if options.panicCallback != nil {
				defer func() {
					if e := recover(); e != nil {
						options.panicCallback(e)
					}
				}()
			}
			if h1 != nil {
				h1(c)
			}
			if h2 != nil {
				h2(c)
			}
		}
	}
	{
		h1 := t.OnSessionServerExpire
		h2 := x.OnSessionServerExpire
		ret.OnSessionServerExpire = func(c CoordinationSessionServerExpireInfo) {
			if options.panicCallback != nil {
				defer func() {
					if e := recover(); e != nil {
						options.panicCallback(e)
					}
				}()
			}
			if h1 != nil {
				h1(c)
			}
			if h2 != nil {
				h2(c)
			}
		}
	}
	{
		h1 := t.OnSessionServerError
		h2 := x.OnSessionServerError
		ret.OnSessionServerError = func(c CoordinationSessionServerErrorInfo) {
			if options.panicCallback != nil {
				defer func() {
					if e := recover(); e != nil {
						options.panicCallback(e)
					}
				}()
			}
			if h1 != nil {
				h1(c)
			}
			if h2 != nil {
				h2(c)
			}
		}
	}
	{
		h1 := t.OnSessionReceive
		h2 := x.OnSessionReceive
		ret.OnSessionReceive = func(c CoordinationSessionReceiveStartInfo) func(CoordinationSessionReceiveDoneInfo) {
			if options.panicCallback != nil {
				defer func() {
					if e := recover(); e != nil {
						options.panicCallback(e)
					}
				}()
			}
			var r, r1 func(CoordinationSessionReceiveDoneInfo)
			if h1 != nil {
				r = h1(c)
			}
			if h2 != nil {
				r1 = h2(c)
			}
			return func(c CoordinationSessionReceiveDoneInfo) {
				if options.panicCallback != nil {
					defer func() {
						if e := recover(); e != nil {
							options.panicCallback(e)
						}
					}()
				}
				if r != nil {
					r(c)
				}
				if r1 != nil {
					r1(c)
				}
			}
		}
	}
	{
		h1 := t.OnSessionReceiveUnexpected
		h2 := x.OnSessionReceiveUnexpected
		ret.OnSessionReceiveUnexpected = func(c CoordinationSessionReceiveUnexpectedInfo) {
			if options.panicCallback != nil {
				defer func() {
					if e := recover(); e != nil {
						options.panicCallback(e)
					}
				}()
			}
			if h1 != nil {
				h1(c)
			}
			if h2 != nil {
				h2(c)
			}
		}
	}
	{
		h1 := t.OnSessionStop
		h2 := x.OnSessionStop
		ret.OnSessionStop = func(c CoordinationSessionStopInfo) {
			if options.panicCallback != nil {
				defer func() {
					if e := recover(); e != nil {
						options.panicCallback(e)
					}
				}()
			}
			if h1 != nil {
				h1(c)
			}
			if h2 != nil {
				h2(c)
			}
		}
	}
	{
		h1 := t.OnSessionStart
		h2 := x.OnSessionStart
		ret.OnSessionStart = func(c CoordinationSessionStartStartInfo) func(CoordinationSessionStartDoneInfo) {
			if options.panicCallback != nil {
				defer func() {
					if e := recover(); e != nil {
						options.panicCallback(e)
					}
				}()
			}
			var r, r1 func(CoordinationSessionStartDoneInfo)
			if h1 != nil {
				r = h1(c)
			}
			if h2 != nil {
				r1 = h2(c)
			}
			return func(c CoordinationSessionStartDoneInfo) {
				if options.panicCallback != nil {
					defer func() {
						if e := recover(); e != nil {
							options.panicCallback(e)
						}
					}()
				}
				if r != nil {
					r(c)
				}
				if r1 != nil {
					r1(c)
				}
			}
		}
	}
	{
		h1 := t.OnSessionSend
		h2 := x.OnSessionSend
		ret.OnSessionSend = func(c CoordinationSessionSendStartInfo) func(CoordinationSessionSendDoneInfo) {
			if options.panicCallback != nil {
				defer func() {
					if e := recover(); e != nil {
						options.panicCallback(e)
					}
				}()
			}
			var r, r1 func(CoordinationSessionSendDoneInfo)
			if h1 != nil {
				r = h1(c)
			}
			if h2 != nil {
				r1 = h2(c)
			}
			return func(c CoordinationSessionSendDoneInfo) {
				if options.panicCallback != nil {
					defer func() {
						if e := recover(); e != nil {
							options.panicCallback(e)
						}
					}()
				}
				if r != nil {
					r(c)
				}
				if r1 != nil {
					r1(c)
				}
			}
		}
	}
	return &ret
}
func (t *Coordination) onNew(c CoordinationNewStartInfo) func(CoordinationNewDoneInfo) {
	fn := t.OnNew
	if fn == nil {
		return func(CoordinationNewDoneInfo) {
			return
		}
	}
	res := fn(c)
	if res == nil {
		return func(CoordinationNewDoneInfo) {
			return
		}
	}
	return res
}
func (t *Coordination) onCreateNode(c CoordinationCreateNodeStartInfo) func(CoordinationCreateNodeDoneInfo) {
	fn := t.OnCreateNode
	if fn == nil {
		return func(CoordinationCreateNodeDoneInfo) {
			return
		}
	}
	res := fn(c)
	if res == nil {
		return func(CoordinationCreateNodeDoneInfo) {
			return
		}
	}
	return res
}
func (t *Coordination) onStreamNew(c CoordinationStreamNewStartInfo) func(CoordinationStreamNewDoneInfo) {
	fn := t.OnStreamNew
	if fn == nil {
		return func(CoordinationStreamNewDoneInfo) {
			return
		}
	}
	res := fn(c)
	if res == nil {
		return func(CoordinationStreamNewDoneInfo) {
			return
		}
	}
	return res
}
func (t *Coordination) onSessionStarted(c CoordinationSessionStartedInfo) {
	fn := t.OnSessionStarted
	if fn == nil {
		return
	}
	fn(c)
}
func (t *Coordination) onSessionStartTimeout(c CoordinationSessionStartTimeoutInfo) {
	fn := t.OnSessionStartTimeout
	if fn == nil {
		return
	}
	fn(c)
}
func (t *Coordination) onSessionKeepAliveTimeout(c CoordinationSessionKeepAliveTimeoutInfo) {
	fn := t.OnSessionKeepAliveTimeout
	if fn == nil {
		return
	}
	fn(c)
}
func (t *Coordination) onSessionStopped(c CoordinationSessionStoppedInfo) {
	fn := t.OnSessionStopped
	if fn == nil {
		return
	}
	fn(c)
}
func (t *Coordination) onSessionStopTimeout(c CoordinationSessionStopTimeoutInfo) {
	fn := t.OnSessionStopTimeout
	if fn == nil {
		return
	}
	fn(c)
}
func (t *Coordination) onSessionClientTimeout(c CoordinationSessionClientTimeoutInfo) {
	fn := t.OnSessionClientTimeout
	if fn == nil {
		return
	}
	fn(c)
}
func (t *Coordination) onSessionServerExpire(c CoordinationSessionServerExpireInfo) {
	fn := t.OnSessionServerExpire
	if fn == nil {
		return
	}
	fn(c)
}
func (t *Coordination) onSessionServerError(c CoordinationSessionServerErrorInfo) {
	fn := t.OnSessionServerError
	if fn == nil {
		return
	}
	fn(c)
}
func (t *Coordination) onSessionReceive(c CoordinationSessionReceiveStartInfo) func(CoordinationSessionReceiveDoneInfo) {
	fn := t.OnSessionReceive
	if fn == nil {
		return func(CoordinationSessionReceiveDoneInfo) {
			return
		}
	}
	res := fn(c)
	if res == nil {
		return func(CoordinationSessionReceiveDoneInfo) {
			return
		}
	}
	return res
}
func (t *Coordination) onSessionReceiveUnexpected(c CoordinationSessionReceiveUnexpectedInfo) {
	fn := t.OnSessionReceiveUnexpected
	if fn == nil {
		return
	}
	fn(c)
}
func (t *Coordination) onSessionStop(c CoordinationSessionStopInfo) {
	fn := t.OnSessionStop
	if fn == nil {
		return
	}
	fn(c)
}
func (t *Coordination) onSessionStart(c CoordinationSessionStartStartInfo) func(CoordinationSessionStartDoneInfo) {
	fn := t.OnSessionStart
	if fn == nil {
		return func(CoordinationSessionStartDoneInfo) {
			return
		}
	}
	res := fn(c)
	if res == nil {
		return func(CoordinationSessionStartDoneInfo) {
			return
		}
	}
	return res
}
func (t *Coordination) onSessionSend(c CoordinationSessionSendStartInfo) func(CoordinationSessionSendDoneInfo) {
	fn := t.OnSessionSend
	if fn == nil {
		return func(CoordinationSessionSendDoneInfo) {
			return
		}
	}
	res := fn(c)
	if res == nil {
		return func(CoordinationSessionSendDoneInfo) {
			return
		}
	}
	return res
}
func CoordinationOnNew(t *Coordination, c *context.Context, call call) func() {
	var p CoordinationNewStartInfo
	p.Context = c
	p.Call = call
	res := t.onNew(p)
	return func() {
		var p CoordinationNewDoneInfo
		res(p)
	}
}
func CoordinationOnCreateNode(t *Coordination, c *context.Context, call call) func(error) {
	var p CoordinationCreateNodeStartInfo
	p.Context = c
	p.Call = call
	res := t.onCreateNode(p)
	return func(e error) {
		var p CoordinationCreateNodeDoneInfo
		p.Error = e
		res(p)
	}
}
func CoordinationOnStreamNew(t *Coordination) func(error) {
	var p CoordinationStreamNewStartInfo
	res := t.onStreamNew(p)
	return func(e error) {
		var p CoordinationStreamNewDoneInfo
		p.Error = e
		res(p)
	}
}
func CoordinationOnSessionStarted(t *Coordination, sessionID uint64, expectedSessionID uint64) {
	var p CoordinationSessionStartedInfo
	p.SessionID = sessionID
	p.ExpectedSessionID = expectedSessionID
	t.onSessionStarted(p)
}
func CoordinationOnSessionStartTimeout(t *Coordination, timeout time.Duration) {
	var p CoordinationSessionStartTimeoutInfo
	p.Timeout = timeout
	t.onSessionStartTimeout(p)
}
func CoordinationOnSessionKeepAliveTimeout(t *Coordination, lastGoodResponseTime time.Time, timeout time.Duration) {
	var p CoordinationSessionKeepAliveTimeoutInfo
	p.LastGoodResponseTime = lastGoodResponseTime
	p.Timeout = timeout
	t.onSessionKeepAliveTimeout(p)
}
func CoordinationOnSessionStopped(t *Coordination, sessionID uint64, expectedSessionID uint64) {
	var p CoordinationSessionStoppedInfo
	p.SessionID = sessionID
	p.ExpectedSessionID = expectedSessionID
	t.onSessionStopped(p)
}
func CoordinationOnSessionStopTimeout(t *Coordination, timeout time.Duration) {
	var p CoordinationSessionStopTimeoutInfo
	p.Timeout = timeout
	t.onSessionStopTimeout(p)
}
func CoordinationOnSessionClientTimeout(t *Coordination, lastGoodResponseTime time.Time, timeout time.Duration) {
	var p CoordinationSessionClientTimeoutInfo
	p.LastGoodResponseTime = lastGoodResponseTime
	p.Timeout = timeout
	t.onSessionClientTimeout(p)
}
func CoordinationOnSessionServerExpire(t *Coordination, failure *Ydb_Coordination.SessionResponse_Failure) {
	var p CoordinationSessionServerExpireInfo
	p.Failure = failure
	t.onSessionServerExpire(p)
}
func CoordinationOnSessionServerError(t *Coordination, failure *Ydb_Coordination.SessionResponse_Failure) {
	var p CoordinationSessionServerErrorInfo
	p.Failure = failure
	t.onSessionServerError(p)
}
func CoordinationOnSessionReceive(t *Coordination) func(response *Ydb_Coordination.SessionResponse, _ error) {
	var p CoordinationSessionReceiveStartInfo
	res := t.onSessionReceive(p)
	return func(response *Ydb_Coordination.SessionResponse, e error) {
		var p CoordinationSessionReceiveDoneInfo
		p.Response = response
		p.Error = e
		res(p)
	}
}
func CoordinationOnSessionReceiveUnexpected(t *Coordination, response *Ydb_Coordination.SessionResponse) {
	var p CoordinationSessionReceiveUnexpectedInfo
	p.Response = response
	t.onSessionReceiveUnexpected(p)
}
func CoordinationOnSessionStop(t *Coordination, sessionID uint64) {
	var p CoordinationSessionStopInfo
	p.SessionID = sessionID
	t.onSessionStop(p)
}
func CoordinationOnSessionStart(t *Coordination) func(error) {
	var p CoordinationSessionStartStartInfo
	res := t.onSessionStart(p)
	return func(e error) {
		var p CoordinationSessionStartDoneInfo
		p.Error = e
		res(p)
	}
}
func CoordinationOnSessionSend(t *Coordination, request *Ydb_Coordination.SessionRequest) func(error) {
	var p CoordinationSessionSendStartInfo
	p.Request = request
	res := t.onSessionSend(p)
	return func(e error) {
		var p CoordinationSessionSendDoneInfo
		p.Error = e
		res(p)
	}
}
