package main

var (
	testData = []struct {
		name    string
		in      string
		out     string
		correct bool
	}{
		{
			name: "reverse order struct",
			in: `package tests
//ydb:generate
type Container struct {
	Struct  Foo
	Structs []Foo
	Bytes   []byte <backtick>ydb:"type:list<uint32>,conv:assert"<backtick>
	Strings []string <backtick>ydb:"type:list<string>"<backtick>
	String  []byte
}
//ydb:generate
type Foo struct {
	ID   string
	Ints []int32
}
//ydb:generate scan
type Foos []Foo
`,
			correct: true,
			out: `// Code generated by ydbgen; DO NOT EDIT.

package tests

import (
	"strconv"

	ydb "github.com/YandexDatabase/ydb-go-sdk/v2"
	"github.com/YandexDatabase/ydb-go-sdk/v2/table"
)

var (
	_ = strconv.Itoa
	_ = ydb.StringValue
	_ = table.NewQueryParameters
)

func (c *Container) Scan(res *table.Result) (err error) {
	res.SeekItem("struct")
	for i0, n0 := 0, res.StructIn(); i0 < n0; i0++ {
		switch res.StructField(i0) {
		case "id":
			c.Struct.ID = res.OUTF8()
		case "ints":
			n1 := res.ListIn()
			xs0 := make([]int32, n1)
			for i1 := 0; i1 < n1; i1++ {
				res.ListItem(i1)
				var x0 int32
				x0 = res.OInt32()
				xs0[i1] = x0
			}
			c.Struct.Ints = xs0
			res.ListOut()
		}
	}
	res.StructOut()

	res.SeekItem("structs")
	n0 := res.ListIn()
	xs0 := make([]Foo, n0)
	for i0 := 0; i0 < n0; i0++ {
		res.ListItem(i0)
		var x0 Foo
		for i1, n1 := 0, res.StructIn(); i1 < n1; i1++ {
			switch res.StructField(i1) {
			case "id":
				x0.ID = res.OUTF8()
			case "ints":
				n2 := res.ListIn()
				xs1 := make([]int32, n2)
				for i2 := 0; i2 < n2; i2++ {
					res.ListItem(i2)
					var x1 int32
					x1 = res.OInt32()
					xs1[i2] = x1
				}
				x0.Ints = xs1
				res.ListOut()
			}
		}
		res.StructOut()
		xs0[i0] = x0
	}
	c.Structs = xs0
	res.ListOut()

	res.SeekItem("bytes")
	n1 := res.ListIn()
	xs1 := make([]byte, n1)
	for i0 := 0; i0 < n1; i0++ {
		res.ListItem(i0)
		var x0 byte
		x0 = ydbConvU32ToB(res.Uint32())
		xs1[i0] = x0
	}
	c.Bytes = xs1
	res.ListOut()

	res.SeekItem("strings")
	n2 := res.ListIn()
	xs2 := make([]string, n2)
	for i0 := 0; i0 < n2; i0++ {
		res.ListItem(i0)
		var x0 string
		x0 = string(res.String())
		xs2[i0] = x0
	}
	c.Strings = xs2
	res.ListOut()

	res.SeekItem("string")
	c.String = res.OString()

	return res.Err()
}

func (c *Container) QueryParameters() *table.QueryParameters {
	var v0 ydb.Value
	{
		var v1 ydb.Value
		{
			var v2 ydb.Value
			{
				vp0 := ydb.OptionalValue(ydb.UTF8Value(c.Struct.ID))
				v2 = vp0
			}
			var v3 ydb.Value
			{
				var list0 ydb.Value
				vs0 := make([]ydb.Value, len(c.Struct.Ints))
				for i0, item0 := range c.Struct.Ints {
					var v4 ydb.Value
					{
						vp0 := ydb.OptionalValue(ydb.Int32Value(item0))
						v4 = vp0
					}
					vs0[i0] = v4
				}
				if len(vs0) == 0 {
					var t1 ydb.Type
					{
						tp0 := ydb.TypeInt32
						t1 = ydb.Optional(tp0)
					}
					t0 := ydb.List(t1)
					list0 = ydb.ZeroValue(t0)
				} else {
					list0 = ydb.ListValue(vs0...)
				}
				v3 = list0
			}
			v1 = ydb.StructValue(
				ydb.StructFieldValue("id", v2),
				ydb.StructFieldValue("ints", v3),
			)
		}
		v0 = v1
	}
	var v1 ydb.Value
	{
		var list0 ydb.Value
		vs0 := make([]ydb.Value, len(c.Structs))
		for i0, item0 := range c.Structs {
			var v2 ydb.Value
			{
				var v3 ydb.Value
				{
					var v4 ydb.Value
					{
						vp0 := ydb.OptionalValue(ydb.UTF8Value(item0.ID))
						v4 = vp0
					}
					var v5 ydb.Value
					{
						var list1 ydb.Value
						vs1 := make([]ydb.Value, len(item0.Ints))
						for i1, item1 := range item0.Ints {
							var v6 ydb.Value
							{
								vp0 := ydb.OptionalValue(ydb.Int32Value(item1))
								v6 = vp0
							}
							vs1[i1] = v6
						}
						if len(vs1) == 0 {
							var t1 ydb.Type
							{
								tp0 := ydb.TypeInt32
								t1 = ydb.Optional(tp0)
							}
							t0 := ydb.List(t1)
							list1 = ydb.ZeroValue(t0)
						} else {
							list1 = ydb.ListValue(vs1...)
						}
						v5 = list1
					}
					v3 = ydb.StructValue(
						ydb.StructFieldValue("id", v4),
						ydb.StructFieldValue("ints", v5),
					)
				}
				v2 = v3
			}
			vs0[i0] = v2
		}
		if len(vs0) == 0 {
			var t1 ydb.Type
			{
				var t2 ydb.Type
				{
					fs0 := make([]ydb.StructOption, 2)
					var t3 ydb.Type
					{
						tp0 := ydb.TypeUTF8
						t3 = ydb.Optional(tp0)
					}
					fs0[0] = ydb.StructField("id", t3)
					var t4 ydb.Type
					{
						var t6 ydb.Type
						{
							tp0 := ydb.TypeInt32
							t6 = ydb.Optional(tp0)
						}
						t5 := ydb.List(t6)
						t4 = t5
					}
					fs0[1] = ydb.StructField("ints", t4)
					t2 = ydb.Struct(fs0...)
				}
				t1 = t2
			}
			t0 := ydb.List(t1)
			list0 = ydb.ZeroValue(t0)
		} else {
			list0 = ydb.ListValue(vs0...)
		}
		v1 = list0
	}
	var v2 ydb.Value
	{
		var list0 ydb.Value
		vs0 := make([]ydb.Value, len(c.Bytes))
		for i0, item0 := range c.Bytes {
			var v3 ydb.Value
			{
				vp0 := ydb.Uint32Value(uint32(item0))
				v3 = vp0
			}
			vs0[i0] = v3
		}
		if len(vs0) == 0 {
			var t1 ydb.Type
			{
				tp0 := ydb.TypeUint32
				t1 = tp0
			}
			t0 := ydb.List(t1)
			list0 = ydb.ZeroValue(t0)
		} else {
			list0 = ydb.ListValue(vs0...)
		}
		v2 = list0
	}
	var v3 ydb.Value
	{
		var list0 ydb.Value
		vs0 := make([]ydb.Value, len(c.Strings))
		for i0, item0 := range c.Strings {
			var v4 ydb.Value
			{
				vp0 := ydb.StringValue([]uint8(item0))
				v4 = vp0
			}
			vs0[i0] = v4
		}
		if len(vs0) == 0 {
			var t1 ydb.Type
			{
				tp0 := ydb.TypeString
				t1 = tp0
			}
			t0 := ydb.List(t1)
			list0 = ydb.ZeroValue(t0)
		} else {
			list0 = ydb.ListValue(vs0...)
		}
		v3 = list0
	}
	var v4 ydb.Value
	{
		vp0 := ydb.OptionalValue(ydb.StringValue(c.String))
		v4 = vp0
	}
	return table.NewQueryParameters(
		table.ValueParam("$struct", v0),
		table.ValueParam("$structs", v1),
		table.ValueParam("$bytes", v2),
		table.ValueParam("$strings", v3),
		table.ValueParam("$string", v4),
	)
}

func (c *Container) StructValue() ydb.Value {
	var v0 ydb.Value
	{
		var v1 ydb.Value
		{
			var v2 ydb.Value
			{
				var v3 ydb.Value
				{
					vp0 := ydb.OptionalValue(ydb.UTF8Value(c.Struct.ID))
					v3 = vp0
				}
				var v4 ydb.Value
				{
					var list0 ydb.Value
					vs0 := make([]ydb.Value, len(c.Struct.Ints))
					for i0, item0 := range c.Struct.Ints {
						var v5 ydb.Value
						{
							vp0 := ydb.OptionalValue(ydb.Int32Value(item0))
							v5 = vp0
						}
						vs0[i0] = v5
					}
					if len(vs0) == 0 {
						var t1 ydb.Type
						{
							tp0 := ydb.TypeInt32
							t1 = ydb.Optional(tp0)
						}
						t0 := ydb.List(t1)
						list0 = ydb.ZeroValue(t0)
					} else {
						list0 = ydb.ListValue(vs0...)
					}
					v4 = list0
				}
				v2 = ydb.StructValue(
					ydb.StructFieldValue("id", v3),
					ydb.StructFieldValue("ints", v4),
				)
			}
			v1 = v2
		}
		var v2 ydb.Value
		{
			var list0 ydb.Value
			vs0 := make([]ydb.Value, len(c.Structs))
			for i0, item0 := range c.Structs {
				var v3 ydb.Value
				{
					var v4 ydb.Value
					{
						var v5 ydb.Value
						{
							vp0 := ydb.OptionalValue(ydb.UTF8Value(item0.ID))
							v5 = vp0
						}
						var v6 ydb.Value
						{
							var list1 ydb.Value
							vs1 := make([]ydb.Value, len(item0.Ints))
							for i1, item1 := range item0.Ints {
								var v7 ydb.Value
								{
									vp0 := ydb.OptionalValue(ydb.Int32Value(item1))
									v7 = vp0
								}
								vs1[i1] = v7
							}
							if len(vs1) == 0 {
								var t1 ydb.Type
								{
									tp0 := ydb.TypeInt32
									t1 = ydb.Optional(tp0)
								}
								t0 := ydb.List(t1)
								list1 = ydb.ZeroValue(t0)
							} else {
								list1 = ydb.ListValue(vs1...)
							}
							v6 = list1
						}
						v4 = ydb.StructValue(
							ydb.StructFieldValue("id", v5),
							ydb.StructFieldValue("ints", v6),
						)
					}
					v3 = v4
				}
				vs0[i0] = v3
			}
			if len(vs0) == 0 {
				var t1 ydb.Type
				{
					var t2 ydb.Type
					{
						fs0 := make([]ydb.StructOption, 2)
						var t3 ydb.Type
						{
							tp0 := ydb.TypeUTF8
							t3 = ydb.Optional(tp0)
						}
						fs0[0] = ydb.StructField("id", t3)
						var t4 ydb.Type
						{
							var t6 ydb.Type
							{
								tp0 := ydb.TypeInt32
								t6 = ydb.Optional(tp0)
							}
							t5 := ydb.List(t6)
							t4 = t5
						}
						fs0[1] = ydb.StructField("ints", t4)
						t2 = ydb.Struct(fs0...)
					}
					t1 = t2
				}
				t0 := ydb.List(t1)
				list0 = ydb.ZeroValue(t0)
			} else {
				list0 = ydb.ListValue(vs0...)
			}
			v2 = list0
		}
		var v3 ydb.Value
		{
			var list0 ydb.Value
			vs0 := make([]ydb.Value, len(c.Bytes))
			for i0, item0 := range c.Bytes {
				var v4 ydb.Value
				{
					vp0 := ydb.Uint32Value(uint32(item0))
					v4 = vp0
				}
				vs0[i0] = v4
			}
			if len(vs0) == 0 {
				var t1 ydb.Type
				{
					tp0 := ydb.TypeUint32
					t1 = tp0
				}
				t0 := ydb.List(t1)
				list0 = ydb.ZeroValue(t0)
			} else {
				list0 = ydb.ListValue(vs0...)
			}
			v3 = list0
		}
		var v4 ydb.Value
		{
			var list0 ydb.Value
			vs0 := make([]ydb.Value, len(c.Strings))
			for i0, item0 := range c.Strings {
				var v5 ydb.Value
				{
					vp0 := ydb.StringValue([]uint8(item0))
					v5 = vp0
				}
				vs0[i0] = v5
			}
			if len(vs0) == 0 {
				var t1 ydb.Type
				{
					tp0 := ydb.TypeString
					t1 = tp0
				}
				t0 := ydb.List(t1)
				list0 = ydb.ZeroValue(t0)
			} else {
				list0 = ydb.ListValue(vs0...)
			}
			v4 = list0
		}
		var v5 ydb.Value
		{
			vp0 := ydb.OptionalValue(ydb.StringValue(c.String))
			v5 = vp0
		}
		v0 = ydb.StructValue(
			ydb.StructFieldValue("struct", v1),
			ydb.StructFieldValue("structs", v2),
			ydb.StructFieldValue("bytes", v3),
			ydb.StructFieldValue("strings", v4),
			ydb.StructFieldValue("string", v5),
		)
	}
	return v0
}

func (c *Container) StructType() ydb.Type {
	var t0 ydb.Type
	{
		fs0 := make([]ydb.StructOption, 5)
		var t1 ydb.Type
		{
			var t2 ydb.Type
			{
				fs1 := make([]ydb.StructOption, 2)
				var t3 ydb.Type
				{
					tp0 := ydb.TypeUTF8
					t3 = ydb.Optional(tp0)
				}
				fs1[0] = ydb.StructField("id", t3)
				var t4 ydb.Type
				{
					var t6 ydb.Type
					{
						tp0 := ydb.TypeInt32
						t6 = ydb.Optional(tp0)
					}
					t5 := ydb.List(t6)
					t4 = t5
				}
				fs1[1] = ydb.StructField("ints", t4)
				t2 = ydb.Struct(fs1...)
			}
			t1 = t2
		}
		fs0[0] = ydb.StructField("struct", t1)
		var t2 ydb.Type
		{
			var t4 ydb.Type
			{
				var t5 ydb.Type
				{
					fs1 := make([]ydb.StructOption, 2)
					var t6 ydb.Type
					{
						tp0 := ydb.TypeUTF8
						t6 = ydb.Optional(tp0)
					}
					fs1[0] = ydb.StructField("id", t6)
					var t7 ydb.Type
					{
						var t9 ydb.Type
						{
							tp0 := ydb.TypeInt32
							t9 = ydb.Optional(tp0)
						}
						t8 := ydb.List(t9)
						t7 = t8
					}
					fs1[1] = ydb.StructField("ints", t7)
					t5 = ydb.Struct(fs1...)
				}
				t4 = t5
			}
			t3 := ydb.List(t4)
			t2 = t3
		}
		fs0[1] = ydb.StructField("structs", t2)
		var t3 ydb.Type
		{
			var t5 ydb.Type
			{
				tp0 := ydb.TypeUint32
				t5 = tp0
			}
			t4 := ydb.List(t5)
			t3 = t4
		}
		fs0[2] = ydb.StructField("bytes", t3)
		var t4 ydb.Type
		{
			var t6 ydb.Type
			{
				tp0 := ydb.TypeString
				t6 = tp0
			}
			t5 := ydb.List(t6)
			t4 = t5
		}
		fs0[3] = ydb.StructField("strings", t4)
		var t5 ydb.Type
		{
			tp0 := ydb.TypeString
			t5 = ydb.Optional(tp0)
		}
		fs0[4] = ydb.StructField("string", t5)
		t0 = ydb.Struct(fs0...)
	}
	return t0
}

func (f *Foo) Scan(res *table.Result) (err error) {
	res.SeekItem("id")
	f.ID = res.OUTF8()

	res.SeekItem("ints")
	n0 := res.ListIn()
	xs0 := make([]int32, n0)
	for i0 := 0; i0 < n0; i0++ {
		res.ListItem(i0)
		var x0 int32
		x0 = res.OInt32()
		xs0[i0] = x0
	}
	f.Ints = xs0
	res.ListOut()

	return res.Err()
}

func (f *Foo) QueryParameters() *table.QueryParameters {
	var v0 ydb.Value
	{
		vp0 := ydb.OptionalValue(ydb.UTF8Value(f.ID))
		v0 = vp0
	}
	var v1 ydb.Value
	{
		var list0 ydb.Value
		vs0 := make([]ydb.Value, len(f.Ints))
		for i0, item0 := range f.Ints {
			var v2 ydb.Value
			{
				vp0 := ydb.OptionalValue(ydb.Int32Value(item0))
				v2 = vp0
			}
			vs0[i0] = v2
		}
		if len(vs0) == 0 {
			var t1 ydb.Type
			{
				tp0 := ydb.TypeInt32
				t1 = ydb.Optional(tp0)
			}
			t0 := ydb.List(t1)
			list0 = ydb.ZeroValue(t0)
		} else {
			list0 = ydb.ListValue(vs0...)
		}
		v1 = list0
	}
	return table.NewQueryParameters(
		table.ValueParam("$id", v0),
		table.ValueParam("$ints", v1),
	)
}

func (f *Foo) StructValue() ydb.Value {
	var v0 ydb.Value
	{
		var v1 ydb.Value
		{
			vp0 := ydb.OptionalValue(ydb.UTF8Value(f.ID))
			v1 = vp0
		}
		var v2 ydb.Value
		{
			var list0 ydb.Value
			vs0 := make([]ydb.Value, len(f.Ints))
			for i0, item0 := range f.Ints {
				var v3 ydb.Value
				{
					vp0 := ydb.OptionalValue(ydb.Int32Value(item0))
					v3 = vp0
				}
				vs0[i0] = v3
			}
			if len(vs0) == 0 {
				var t1 ydb.Type
				{
					tp0 := ydb.TypeInt32
					t1 = ydb.Optional(tp0)
				}
				t0 := ydb.List(t1)
				list0 = ydb.ZeroValue(t0)
			} else {
				list0 = ydb.ListValue(vs0...)
			}
			v2 = list0
		}
		v0 = ydb.StructValue(
			ydb.StructFieldValue("id", v1),
			ydb.StructFieldValue("ints", v2),
		)
	}
	return v0
}

func (f *Foo) StructType() ydb.Type {
	var t0 ydb.Type
	{
		fs0 := make([]ydb.StructOption, 2)
		var t1 ydb.Type
		{
			tp0 := ydb.TypeUTF8
			t1 = ydb.Optional(tp0)
		}
		fs0[0] = ydb.StructField("id", t1)
		var t2 ydb.Type
		{
			var t4 ydb.Type
			{
				tp0 := ydb.TypeInt32
				t4 = ydb.Optional(tp0)
			}
			t3 := ydb.List(t4)
			t2 = t3
		}
		fs0[1] = ydb.StructField("ints", t2)
		t0 = ydb.Struct(fs0...)
	}
	return t0
}

func (fs *Foos) Scan(res *table.Result) (err error) {
	for res.NextRow() {
		var x0 Foo
		res.SeekItem("id")
		x0.ID = res.OUTF8()

		res.SeekItem("ints")
		n0 := res.ListIn()
		xs0 := make([]int32, n0)
		for i0 := 0; i0 < n0; i0++ {
			res.ListItem(i0)
			var x1 int32
			x1 = res.OInt32()
			xs0[i0] = x1
		}
		x0.Ints = xs0
		res.ListOut()

		if res.Err() == nil {
			*fs = append(*fs, x0)
		}
	}
	return res.Err()
}

func ydbConvU32ToB(x uint32) byte {
	const (
		bits = 8
		mask = (1 << (bits)) - 1
	)
	abs := uint64(x)
	if abs&mask != abs {
		panic(
			"ydbgen: convassert: " + strconv.FormatUint(uint64(x), 10) +
				" (type uint32) overflows byte",
		)
	}
	return byte(x)
}

`,
		},
		{
			name: "complex dependency struct",
			in: `package tests
//ydb:generate
type Painter struct {
	Struct  []Figure
	Structs []Point
	Bytes   []byte <backtick>ydb:"type:list<uint32>,conv:assert"<backtick>
	Strings []string <backtick>ydb:"type:list<string>"<backtick>
	String  []byte
}
//ydb:generate
type Place struct {
	FigPlace Point
}
//ydb:generate
type Point struct {
	x float64 <backtick>ydb:"type:float"<backtick>
	y float64 <backtick>ydb:"type:float"<backtick>
}
//ydb:generate
type Figure struct {
	FigPlace Place
	Points   []Point
}
//ydb:generate scan
type Points []Point
`,
			correct: true,
			out: `// Code generated by ydbgen; DO NOT EDIT.

package tests

import (
	"strconv"

	ydb "github.com/YandexDatabase/ydb-go-sdk/v2"
	"github.com/YandexDatabase/ydb-go-sdk/v2/table"
)

var (
	_ = strconv.Itoa
	_ = ydb.StringValue
	_ = table.NewQueryParameters
)

func (p *Painter) Scan(res *table.Result) (err error) {
	res.SeekItem("struct")
	n0 := res.ListIn()
	xs0 := make([]Figure, n0)
	for i0 := 0; i0 < n0; i0++ {
		res.ListItem(i0)
		var x0 Figure
		for i1, n1 := 0, res.StructIn(); i1 < n1; i1++ {
			switch res.StructField(i1) {
			case "fig_place":
				for i2, n2 := 0, res.StructIn(); i2 < n2; i2++ {
					switch res.StructField(i2) {
					case "fig_place":
						for i3, n3 := 0, res.StructIn(); i3 < n3; i3++ {
							switch res.StructField(i3) {
							case "x":
								x0.FigPlace.FigPlace.x = float64(res.Float())
							case "y":
								x0.FigPlace.FigPlace.y = float64(res.Float())
							}
						}
						res.StructOut()
					}
				}
				res.StructOut()
			case "points":
				n2 := res.ListIn()
				xs1 := make([]Point, n2)
				for i2 := 0; i2 < n2; i2++ {
					res.ListItem(i2)
					var x1 Point
					for i3, n3 := 0, res.StructIn(); i3 < n3; i3++ {
						switch res.StructField(i3) {
						case "x":
							x1.x = float64(res.Float())
						case "y":
							x1.y = float64(res.Float())
						}
					}
					res.StructOut()
					xs1[i2] = x1
				}
				x0.Points = xs1
				res.ListOut()
			}
		}
		res.StructOut()
		xs0[i0] = x0
	}
	p.Struct = xs0
	res.ListOut()

	res.SeekItem("structs")
	n1 := res.ListIn()
	xs1 := make([]Point, n1)
	for i0 := 0; i0 < n1; i0++ {
		res.ListItem(i0)
		var x0 Point
		for i1, n2 := 0, res.StructIn(); i1 < n2; i1++ {
			switch res.StructField(i1) {
			case "x":
				x0.x = float64(res.Float())
			case "y":
				x0.y = float64(res.Float())
			}
		}
		res.StructOut()
		xs1[i0] = x0
	}
	p.Structs = xs1
	res.ListOut()

	res.SeekItem("bytes")
	n2 := res.ListIn()
	xs2 := make([]byte, n2)
	for i0 := 0; i0 < n2; i0++ {
		res.ListItem(i0)
		var x0 byte
		x0 = ydbConvU32ToB(res.Uint32())
		xs2[i0] = x0
	}
	p.Bytes = xs2
	res.ListOut()

	res.SeekItem("strings")
	n3 := res.ListIn()
	xs3 := make([]string, n3)
	for i0 := 0; i0 < n3; i0++ {
		res.ListItem(i0)
		var x0 string
		x0 = string(res.String())
		xs3[i0] = x0
	}
	p.Strings = xs3
	res.ListOut()

	res.SeekItem("string")
	p.String = res.OString()

	return res.Err()
}

func (p *Painter) QueryParameters() *table.QueryParameters {
	var v0 ydb.Value
	{
		var list0 ydb.Value
		vs0 := make([]ydb.Value, len(p.Struct))
		for i0, item0 := range p.Struct {
			var v1 ydb.Value
			{
				var v2 ydb.Value
				{
					var v3 ydb.Value
					{
						var v4 ydb.Value
						{
							var v5 ydb.Value
							{
								var v6 ydb.Value
								{
									var v7 ydb.Value
									{
										vp0 := ydb.FloatValue(float32(item0.FigPlace.FigPlace.x))
										v7 = vp0
									}
									var v8 ydb.Value
									{
										vp0 := ydb.FloatValue(float32(item0.FigPlace.FigPlace.y))
										v8 = vp0
									}
									v6 = ydb.StructValue(
										ydb.StructFieldValue("x", v7),
										ydb.StructFieldValue("y", v8),
									)
								}
								v5 = v6
							}
							v4 = ydb.StructValue(
								ydb.StructFieldValue("fig_place", v5),
							)
						}
						v3 = v4
					}
					var v4 ydb.Value
					{
						var list1 ydb.Value
						vs1 := make([]ydb.Value, len(item0.Points))
						for i1, item1 := range item0.Points {
							var v5 ydb.Value
							{
								var v6 ydb.Value
								{
									var v7 ydb.Value
									{
										vp0 := ydb.FloatValue(float32(item1.x))
										v7 = vp0
									}
									var v8 ydb.Value
									{
										vp0 := ydb.FloatValue(float32(item1.y))
										v8 = vp0
									}
									v6 = ydb.StructValue(
										ydb.StructFieldValue("x", v7),
										ydb.StructFieldValue("y", v8),
									)
								}
								v5 = v6
							}
							vs1[i1] = v5
						}
						if len(vs1) == 0 {
							var t1 ydb.Type
							{
								var t2 ydb.Type
								{
									fs0 := make([]ydb.StructOption, 2)
									var t3 ydb.Type
									{
										tp0 := ydb.TypeFloat
										t3 = tp0
									}
									fs0[0] = ydb.StructField("x", t3)
									var t4 ydb.Type
									{
										tp0 := ydb.TypeFloat
										t4 = tp0
									}
									fs0[1] = ydb.StructField("y", t4)
									t2 = ydb.Struct(fs0...)
								}
								t1 = t2
							}
							t0 := ydb.List(t1)
							list1 = ydb.ZeroValue(t0)
						} else {
							list1 = ydb.ListValue(vs1...)
						}
						v4 = list1
					}
					v2 = ydb.StructValue(
						ydb.StructFieldValue("fig_place", v3),
						ydb.StructFieldValue("points", v4),
					)
				}
				v1 = v2
			}
			vs0[i0] = v1
		}
		if len(vs0) == 0 {
			var t1 ydb.Type
			{
				var t2 ydb.Type
				{
					fs0 := make([]ydb.StructOption, 2)
					var t3 ydb.Type
					{
						var t4 ydb.Type
						{
							fs1 := make([]ydb.StructOption, 1)
							var t5 ydb.Type
							{
								var t6 ydb.Type
								{
									fs2 := make([]ydb.StructOption, 2)
									var t7 ydb.Type
									{
										tp0 := ydb.TypeFloat
										t7 = tp0
									}
									fs2[0] = ydb.StructField("x", t7)
									var t8 ydb.Type
									{
										tp0 := ydb.TypeFloat
										t8 = tp0
									}
									fs2[1] = ydb.StructField("y", t8)
									t6 = ydb.Struct(fs2...)
								}
								t5 = t6
							}
							fs1[0] = ydb.StructField("fig_place", t5)
							t4 = ydb.Struct(fs1...)
						}
						t3 = t4
					}
					fs0[0] = ydb.StructField("fig_place", t3)
					var t4 ydb.Type
					{
						var t6 ydb.Type
						{
							var t7 ydb.Type
							{
								fs1 := make([]ydb.StructOption, 2)
								var t8 ydb.Type
								{
									tp0 := ydb.TypeFloat
									t8 = tp0
								}
								fs1[0] = ydb.StructField("x", t8)
								var t9 ydb.Type
								{
									tp0 := ydb.TypeFloat
									t9 = tp0
								}
								fs1[1] = ydb.StructField("y", t9)
								t7 = ydb.Struct(fs1...)
							}
							t6 = t7
						}
						t5 := ydb.List(t6)
						t4 = t5
					}
					fs0[1] = ydb.StructField("points", t4)
					t2 = ydb.Struct(fs0...)
				}
				t1 = t2
			}
			t0 := ydb.List(t1)
			list0 = ydb.ZeroValue(t0)
		} else {
			list0 = ydb.ListValue(vs0...)
		}
		v0 = list0
	}
	var v1 ydb.Value
	{
		var list0 ydb.Value
		vs0 := make([]ydb.Value, len(p.Structs))
		for i0, item0 := range p.Structs {
			var v2 ydb.Value
			{
				var v3 ydb.Value
				{
					var v4 ydb.Value
					{
						vp0 := ydb.FloatValue(float32(item0.x))
						v4 = vp0
					}
					var v5 ydb.Value
					{
						vp0 := ydb.FloatValue(float32(item0.y))
						v5 = vp0
					}
					v3 = ydb.StructValue(
						ydb.StructFieldValue("x", v4),
						ydb.StructFieldValue("y", v5),
					)
				}
				v2 = v3
			}
			vs0[i0] = v2
		}
		if len(vs0) == 0 {
			var t1 ydb.Type
			{
				var t2 ydb.Type
				{
					fs0 := make([]ydb.StructOption, 2)
					var t3 ydb.Type
					{
						tp0 := ydb.TypeFloat
						t3 = tp0
					}
					fs0[0] = ydb.StructField("x", t3)
					var t4 ydb.Type
					{
						tp0 := ydb.TypeFloat
						t4 = tp0
					}
					fs0[1] = ydb.StructField("y", t4)
					t2 = ydb.Struct(fs0...)
				}
				t1 = t2
			}
			t0 := ydb.List(t1)
			list0 = ydb.ZeroValue(t0)
		} else {
			list0 = ydb.ListValue(vs0...)
		}
		v1 = list0
	}
	var v2 ydb.Value
	{
		var list0 ydb.Value
		vs0 := make([]ydb.Value, len(p.Bytes))
		for i0, item0 := range p.Bytes {
			var v3 ydb.Value
			{
				vp0 := ydb.Uint32Value(uint32(item0))
				v3 = vp0
			}
			vs0[i0] = v3
		}
		if len(vs0) == 0 {
			var t1 ydb.Type
			{
				tp0 := ydb.TypeUint32
				t1 = tp0
			}
			t0 := ydb.List(t1)
			list0 = ydb.ZeroValue(t0)
		} else {
			list0 = ydb.ListValue(vs0...)
		}
		v2 = list0
	}
	var v3 ydb.Value
	{
		var list0 ydb.Value
		vs0 := make([]ydb.Value, len(p.Strings))
		for i0, item0 := range p.Strings {
			var v4 ydb.Value
			{
				vp0 := ydb.StringValue([]uint8(item0))
				v4 = vp0
			}
			vs0[i0] = v4
		}
		if len(vs0) == 0 {
			var t1 ydb.Type
			{
				tp0 := ydb.TypeString
				t1 = tp0
			}
			t0 := ydb.List(t1)
			list0 = ydb.ZeroValue(t0)
		} else {
			list0 = ydb.ListValue(vs0...)
		}
		v3 = list0
	}
	var v4 ydb.Value
	{
		vp0 := ydb.OptionalValue(ydb.StringValue(p.String))
		v4 = vp0
	}
	return table.NewQueryParameters(
		table.ValueParam("$struct", v0),
		table.ValueParam("$structs", v1),
		table.ValueParam("$bytes", v2),
		table.ValueParam("$strings", v3),
		table.ValueParam("$string", v4),
	)
}

func (p *Painter) StructValue() ydb.Value {
	var v0 ydb.Value
	{
		var v1 ydb.Value
		{
			var list0 ydb.Value
			vs0 := make([]ydb.Value, len(p.Struct))
			for i0, item0 := range p.Struct {
				var v2 ydb.Value
				{
					var v3 ydb.Value
					{
						var v4 ydb.Value
						{
							var v5 ydb.Value
							{
								var v6 ydb.Value
								{
									var v7 ydb.Value
									{
										var v8 ydb.Value
										{
											vp0 := ydb.FloatValue(float32(item0.FigPlace.FigPlace.x))
											v8 = vp0
										}
										var v9 ydb.Value
										{
											vp0 := ydb.FloatValue(float32(item0.FigPlace.FigPlace.y))
											v9 = vp0
										}
										v7 = ydb.StructValue(
											ydb.StructFieldValue("x", v8),
											ydb.StructFieldValue("y", v9),
										)
									}
									v6 = v7
								}
								v5 = ydb.StructValue(
									ydb.StructFieldValue("fig_place", v6),
								)
							}
							v4 = v5
						}
						var v5 ydb.Value
						{
							var list1 ydb.Value
							vs1 := make([]ydb.Value, len(item0.Points))
							for i1, item1 := range item0.Points {
								var v6 ydb.Value
								{
									var v7 ydb.Value
									{
										var v8 ydb.Value
										{
											vp0 := ydb.FloatValue(float32(item1.x))
											v8 = vp0
										}
										var v9 ydb.Value
										{
											vp0 := ydb.FloatValue(float32(item1.y))
											v9 = vp0
										}
										v7 = ydb.StructValue(
											ydb.StructFieldValue("x", v8),
											ydb.StructFieldValue("y", v9),
										)
									}
									v6 = v7
								}
								vs1[i1] = v6
							}
							if len(vs1) == 0 {
								var t1 ydb.Type
								{
									var t2 ydb.Type
									{
										fs0 := make([]ydb.StructOption, 2)
										var t3 ydb.Type
										{
											tp0 := ydb.TypeFloat
											t3 = tp0
										}
										fs0[0] = ydb.StructField("x", t3)
										var t4 ydb.Type
										{
											tp0 := ydb.TypeFloat
											t4 = tp0
										}
										fs0[1] = ydb.StructField("y", t4)
										t2 = ydb.Struct(fs0...)
									}
									t1 = t2
								}
								t0 := ydb.List(t1)
								list1 = ydb.ZeroValue(t0)
							} else {
								list1 = ydb.ListValue(vs1...)
							}
							v5 = list1
						}
						v3 = ydb.StructValue(
							ydb.StructFieldValue("fig_place", v4),
							ydb.StructFieldValue("points", v5),
						)
					}
					v2 = v3
				}
				vs0[i0] = v2
			}
			if len(vs0) == 0 {
				var t1 ydb.Type
				{
					var t2 ydb.Type
					{
						fs0 := make([]ydb.StructOption, 2)
						var t3 ydb.Type
						{
							var t4 ydb.Type
							{
								fs1 := make([]ydb.StructOption, 1)
								var t5 ydb.Type
								{
									var t6 ydb.Type
									{
										fs2 := make([]ydb.StructOption, 2)
										var t7 ydb.Type
										{
											tp0 := ydb.TypeFloat
											t7 = tp0
										}
										fs2[0] = ydb.StructField("x", t7)
										var t8 ydb.Type
										{
											tp0 := ydb.TypeFloat
											t8 = tp0
										}
										fs2[1] = ydb.StructField("y", t8)
										t6 = ydb.Struct(fs2...)
									}
									t5 = t6
								}
								fs1[0] = ydb.StructField("fig_place", t5)
								t4 = ydb.Struct(fs1...)
							}
							t3 = t4
						}
						fs0[0] = ydb.StructField("fig_place", t3)
						var t4 ydb.Type
						{
							var t6 ydb.Type
							{
								var t7 ydb.Type
								{
									fs1 := make([]ydb.StructOption, 2)
									var t8 ydb.Type
									{
										tp0 := ydb.TypeFloat
										t8 = tp0
									}
									fs1[0] = ydb.StructField("x", t8)
									var t9 ydb.Type
									{
										tp0 := ydb.TypeFloat
										t9 = tp0
									}
									fs1[1] = ydb.StructField("y", t9)
									t7 = ydb.Struct(fs1...)
								}
								t6 = t7
							}
							t5 := ydb.List(t6)
							t4 = t5
						}
						fs0[1] = ydb.StructField("points", t4)
						t2 = ydb.Struct(fs0...)
					}
					t1 = t2
				}
				t0 := ydb.List(t1)
				list0 = ydb.ZeroValue(t0)
			} else {
				list0 = ydb.ListValue(vs0...)
			}
			v1 = list0
		}
		var v2 ydb.Value
		{
			var list0 ydb.Value
			vs0 := make([]ydb.Value, len(p.Structs))
			for i0, item0 := range p.Structs {
				var v3 ydb.Value
				{
					var v4 ydb.Value
					{
						var v5 ydb.Value
						{
							vp0 := ydb.FloatValue(float32(item0.x))
							v5 = vp0
						}
						var v6 ydb.Value
						{
							vp0 := ydb.FloatValue(float32(item0.y))
							v6 = vp0
						}
						v4 = ydb.StructValue(
							ydb.StructFieldValue("x", v5),
							ydb.StructFieldValue("y", v6),
						)
					}
					v3 = v4
				}
				vs0[i0] = v3
			}
			if len(vs0) == 0 {
				var t1 ydb.Type
				{
					var t2 ydb.Type
					{
						fs0 := make([]ydb.StructOption, 2)
						var t3 ydb.Type
						{
							tp0 := ydb.TypeFloat
							t3 = tp0
						}
						fs0[0] = ydb.StructField("x", t3)
						var t4 ydb.Type
						{
							tp0 := ydb.TypeFloat
							t4 = tp0
						}
						fs0[1] = ydb.StructField("y", t4)
						t2 = ydb.Struct(fs0...)
					}
					t1 = t2
				}
				t0 := ydb.List(t1)
				list0 = ydb.ZeroValue(t0)
			} else {
				list0 = ydb.ListValue(vs0...)
			}
			v2 = list0
		}
		var v3 ydb.Value
		{
			var list0 ydb.Value
			vs0 := make([]ydb.Value, len(p.Bytes))
			for i0, item0 := range p.Bytes {
				var v4 ydb.Value
				{
					vp0 := ydb.Uint32Value(uint32(item0))
					v4 = vp0
				}
				vs0[i0] = v4
			}
			if len(vs0) == 0 {
				var t1 ydb.Type
				{
					tp0 := ydb.TypeUint32
					t1 = tp0
				}
				t0 := ydb.List(t1)
				list0 = ydb.ZeroValue(t0)
			} else {
				list0 = ydb.ListValue(vs0...)
			}
			v3 = list0
		}
		var v4 ydb.Value
		{
			var list0 ydb.Value
			vs0 := make([]ydb.Value, len(p.Strings))
			for i0, item0 := range p.Strings {
				var v5 ydb.Value
				{
					vp0 := ydb.StringValue([]uint8(item0))
					v5 = vp0
				}
				vs0[i0] = v5
			}
			if len(vs0) == 0 {
				var t1 ydb.Type
				{
					tp0 := ydb.TypeString
					t1 = tp0
				}
				t0 := ydb.List(t1)
				list0 = ydb.ZeroValue(t0)
			} else {
				list0 = ydb.ListValue(vs0...)
			}
			v4 = list0
		}
		var v5 ydb.Value
		{
			vp0 := ydb.OptionalValue(ydb.StringValue(p.String))
			v5 = vp0
		}
		v0 = ydb.StructValue(
			ydb.StructFieldValue("struct", v1),
			ydb.StructFieldValue("structs", v2),
			ydb.StructFieldValue("bytes", v3),
			ydb.StructFieldValue("strings", v4),
			ydb.StructFieldValue("string", v5),
		)
	}
	return v0
}

func (p *Painter) StructType() ydb.Type {
	var t0 ydb.Type
	{
		fs0 := make([]ydb.StructOption, 5)
		var t1 ydb.Type
		{
			var t3 ydb.Type
			{
				var t4 ydb.Type
				{
					fs1 := make([]ydb.StructOption, 2)
					var t5 ydb.Type
					{
						var t6 ydb.Type
						{
							fs2 := make([]ydb.StructOption, 1)
							var t7 ydb.Type
							{
								var t8 ydb.Type
								{
									fs3 := make([]ydb.StructOption, 2)
									var t9 ydb.Type
									{
										tp0 := ydb.TypeFloat
										t9 = tp0
									}
									fs3[0] = ydb.StructField("x", t9)
									var t10 ydb.Type
									{
										tp0 := ydb.TypeFloat
										t10 = tp0
									}
									fs3[1] = ydb.StructField("y", t10)
									t8 = ydb.Struct(fs3...)
								}
								t7 = t8
							}
							fs2[0] = ydb.StructField("fig_place", t7)
							t6 = ydb.Struct(fs2...)
						}
						t5 = t6
					}
					fs1[0] = ydb.StructField("fig_place", t5)
					var t6 ydb.Type
					{
						var t8 ydb.Type
						{
							var t9 ydb.Type
							{
								fs2 := make([]ydb.StructOption, 2)
								var t10 ydb.Type
								{
									tp0 := ydb.TypeFloat
									t10 = tp0
								}
								fs2[0] = ydb.StructField("x", t10)
								var t11 ydb.Type
								{
									tp0 := ydb.TypeFloat
									t11 = tp0
								}
								fs2[1] = ydb.StructField("y", t11)
								t9 = ydb.Struct(fs2...)
							}
							t8 = t9
						}
						t7 := ydb.List(t8)
						t6 = t7
					}
					fs1[1] = ydb.StructField("points", t6)
					t4 = ydb.Struct(fs1...)
				}
				t3 = t4
			}
			t2 := ydb.List(t3)
			t1 = t2
		}
		fs0[0] = ydb.StructField("struct", t1)
		var t2 ydb.Type
		{
			var t4 ydb.Type
			{
				var t5 ydb.Type
				{
					fs1 := make([]ydb.StructOption, 2)
					var t6 ydb.Type
					{
						tp0 := ydb.TypeFloat
						t6 = tp0
					}
					fs1[0] = ydb.StructField("x", t6)
					var t7 ydb.Type
					{
						tp0 := ydb.TypeFloat
						t7 = tp0
					}
					fs1[1] = ydb.StructField("y", t7)
					t5 = ydb.Struct(fs1...)
				}
				t4 = t5
			}
			t3 := ydb.List(t4)
			t2 = t3
		}
		fs0[1] = ydb.StructField("structs", t2)
		var t3 ydb.Type
		{
			var t5 ydb.Type
			{
				tp0 := ydb.TypeUint32
				t5 = tp0
			}
			t4 := ydb.List(t5)
			t3 = t4
		}
		fs0[2] = ydb.StructField("bytes", t3)
		var t4 ydb.Type
		{
			var t6 ydb.Type
			{
				tp0 := ydb.TypeString
				t6 = tp0
			}
			t5 := ydb.List(t6)
			t4 = t5
		}
		fs0[3] = ydb.StructField("strings", t4)
		var t5 ydb.Type
		{
			tp0 := ydb.TypeString
			t5 = ydb.Optional(tp0)
		}
		fs0[4] = ydb.StructField("string", t5)
		t0 = ydb.Struct(fs0...)
	}
	return t0
}

func (p *Place) Scan(res *table.Result) (err error) {
	res.SeekItem("fig_place")
	for i0, n0 := 0, res.StructIn(); i0 < n0; i0++ {
		switch res.StructField(i0) {
		case "x":
			p.FigPlace.x = float64(res.Float())
		case "y":
			p.FigPlace.y = float64(res.Float())
		}
	}
	res.StructOut()

	return res.Err()
}

func (p *Place) QueryParameters() *table.QueryParameters {
	var v0 ydb.Value
	{
		var v1 ydb.Value
		{
			var v2 ydb.Value
			{
				vp0 := ydb.FloatValue(float32(p.FigPlace.x))
				v2 = vp0
			}
			var v3 ydb.Value
			{
				vp0 := ydb.FloatValue(float32(p.FigPlace.y))
				v3 = vp0
			}
			v1 = ydb.StructValue(
				ydb.StructFieldValue("x", v2),
				ydb.StructFieldValue("y", v3),
			)
		}
		v0 = v1
	}
	return table.NewQueryParameters(
		table.ValueParam("$fig_place", v0),
	)
}

func (p *Place) StructValue() ydb.Value {
	var v0 ydb.Value
	{
		var v1 ydb.Value
		{
			var v2 ydb.Value
			{
				var v3 ydb.Value
				{
					vp0 := ydb.FloatValue(float32(p.FigPlace.x))
					v3 = vp0
				}
				var v4 ydb.Value
				{
					vp0 := ydb.FloatValue(float32(p.FigPlace.y))
					v4 = vp0
				}
				v2 = ydb.StructValue(
					ydb.StructFieldValue("x", v3),
					ydb.StructFieldValue("y", v4),
				)
			}
			v1 = v2
		}
		v0 = ydb.StructValue(
			ydb.StructFieldValue("fig_place", v1),
		)
	}
	return v0
}

func (p *Place) StructType() ydb.Type {
	var t0 ydb.Type
	{
		fs0 := make([]ydb.StructOption, 1)
		var t1 ydb.Type
		{
			var t2 ydb.Type
			{
				fs1 := make([]ydb.StructOption, 2)
				var t3 ydb.Type
				{
					tp0 := ydb.TypeFloat
					t3 = tp0
				}
				fs1[0] = ydb.StructField("x", t3)
				var t4 ydb.Type
				{
					tp0 := ydb.TypeFloat
					t4 = tp0
				}
				fs1[1] = ydb.StructField("y", t4)
				t2 = ydb.Struct(fs1...)
			}
			t1 = t2
		}
		fs0[0] = ydb.StructField("fig_place", t1)
		t0 = ydb.Struct(fs0...)
	}
	return t0
}

func (p *Point) Scan(res *table.Result) (err error) {
	res.SeekItem("x")
	p.x = float64(res.Float())

	res.SeekItem("y")
	p.y = float64(res.Float())

	return res.Err()
}

func (p *Point) QueryParameters() *table.QueryParameters {
	var v0 ydb.Value
	{
		vp0 := ydb.FloatValue(float32(p.x))
		v0 = vp0
	}
	var v1 ydb.Value
	{
		vp0 := ydb.FloatValue(float32(p.y))
		v1 = vp0
	}
	return table.NewQueryParameters(
		table.ValueParam("$x", v0),
		table.ValueParam("$y", v1),
	)
}

func (p *Point) StructValue() ydb.Value {
	var v0 ydb.Value
	{
		var v1 ydb.Value
		{
			vp0 := ydb.FloatValue(float32(p.x))
			v1 = vp0
		}
		var v2 ydb.Value
		{
			vp0 := ydb.FloatValue(float32(p.y))
			v2 = vp0
		}
		v0 = ydb.StructValue(
			ydb.StructFieldValue("x", v1),
			ydb.StructFieldValue("y", v2),
		)
	}
	return v0
}

func (p *Point) StructType() ydb.Type {
	var t0 ydb.Type
	{
		fs0 := make([]ydb.StructOption, 2)
		var t1 ydb.Type
		{
			tp0 := ydb.TypeFloat
			t1 = tp0
		}
		fs0[0] = ydb.StructField("x", t1)
		var t2 ydb.Type
		{
			tp0 := ydb.TypeFloat
			t2 = tp0
		}
		fs0[1] = ydb.StructField("y", t2)
		t0 = ydb.Struct(fs0...)
	}
	return t0
}

func (f *Figure) Scan(res *table.Result) (err error) {
	res.SeekItem("fig_place")
	for i0, n0 := 0, res.StructIn(); i0 < n0; i0++ {
		switch res.StructField(i0) {
		case "fig_place":
			for i1, n1 := 0, res.StructIn(); i1 < n1; i1++ {
				switch res.StructField(i1) {
				case "x":
					f.FigPlace.FigPlace.x = float64(res.Float())
				case "y":
					f.FigPlace.FigPlace.y = float64(res.Float())
				}
			}
			res.StructOut()
		}
	}
	res.StructOut()

	res.SeekItem("points")
	n0 := res.ListIn()
	xs0 := make([]Point, n0)
	for i0 := 0; i0 < n0; i0++ {
		res.ListItem(i0)
		var x0 Point
		for i1, n1 := 0, res.StructIn(); i1 < n1; i1++ {
			switch res.StructField(i1) {
			case "x":
				x0.x = float64(res.Float())
			case "y":
				x0.y = float64(res.Float())
			}
		}
		res.StructOut()
		xs0[i0] = x0
	}
	f.Points = xs0
	res.ListOut()

	return res.Err()
}

func (f *Figure) QueryParameters() *table.QueryParameters {
	var v0 ydb.Value
	{
		var v1 ydb.Value
		{
			var v2 ydb.Value
			{
				var v3 ydb.Value
				{
					var v4 ydb.Value
					{
						vp0 := ydb.FloatValue(float32(f.FigPlace.FigPlace.x))
						v4 = vp0
					}
					var v5 ydb.Value
					{
						vp0 := ydb.FloatValue(float32(f.FigPlace.FigPlace.y))
						v5 = vp0
					}
					v3 = ydb.StructValue(
						ydb.StructFieldValue("x", v4),
						ydb.StructFieldValue("y", v5),
					)
				}
				v2 = v3
			}
			v1 = ydb.StructValue(
				ydb.StructFieldValue("fig_place", v2),
			)
		}
		v0 = v1
	}
	var v1 ydb.Value
	{
		var list0 ydb.Value
		vs0 := make([]ydb.Value, len(f.Points))
		for i0, item0 := range f.Points {
			var v2 ydb.Value
			{
				var v3 ydb.Value
				{
					var v4 ydb.Value
					{
						vp0 := ydb.FloatValue(float32(item0.x))
						v4 = vp0
					}
					var v5 ydb.Value
					{
						vp0 := ydb.FloatValue(float32(item0.y))
						v5 = vp0
					}
					v3 = ydb.StructValue(
						ydb.StructFieldValue("x", v4),
						ydb.StructFieldValue("y", v5),
					)
				}
				v2 = v3
			}
			vs0[i0] = v2
		}
		if len(vs0) == 0 {
			var t1 ydb.Type
			{
				var t2 ydb.Type
				{
					fs0 := make([]ydb.StructOption, 2)
					var t3 ydb.Type
					{
						tp0 := ydb.TypeFloat
						t3 = tp0
					}
					fs0[0] = ydb.StructField("x", t3)
					var t4 ydb.Type
					{
						tp0 := ydb.TypeFloat
						t4 = tp0
					}
					fs0[1] = ydb.StructField("y", t4)
					t2 = ydb.Struct(fs0...)
				}
				t1 = t2
			}
			t0 := ydb.List(t1)
			list0 = ydb.ZeroValue(t0)
		} else {
			list0 = ydb.ListValue(vs0...)
		}
		v1 = list0
	}
	return table.NewQueryParameters(
		table.ValueParam("$fig_place", v0),
		table.ValueParam("$points", v1),
	)
}

func (f *Figure) StructValue() ydb.Value {
	var v0 ydb.Value
	{
		var v1 ydb.Value
		{
			var v2 ydb.Value
			{
				var v3 ydb.Value
				{
					var v4 ydb.Value
					{
						var v5 ydb.Value
						{
							vp0 := ydb.FloatValue(float32(f.FigPlace.FigPlace.x))
							v5 = vp0
						}
						var v6 ydb.Value
						{
							vp0 := ydb.FloatValue(float32(f.FigPlace.FigPlace.y))
							v6 = vp0
						}
						v4 = ydb.StructValue(
							ydb.StructFieldValue("x", v5),
							ydb.StructFieldValue("y", v6),
						)
					}
					v3 = v4
				}
				v2 = ydb.StructValue(
					ydb.StructFieldValue("fig_place", v3),
				)
			}
			v1 = v2
		}
		var v2 ydb.Value
		{
			var list0 ydb.Value
			vs0 := make([]ydb.Value, len(f.Points))
			for i0, item0 := range f.Points {
				var v3 ydb.Value
				{
					var v4 ydb.Value
					{
						var v5 ydb.Value
						{
							vp0 := ydb.FloatValue(float32(item0.x))
							v5 = vp0
						}
						var v6 ydb.Value
						{
							vp0 := ydb.FloatValue(float32(item0.y))
							v6 = vp0
						}
						v4 = ydb.StructValue(
							ydb.StructFieldValue("x", v5),
							ydb.StructFieldValue("y", v6),
						)
					}
					v3 = v4
				}
				vs0[i0] = v3
			}
			if len(vs0) == 0 {
				var t1 ydb.Type
				{
					var t2 ydb.Type
					{
						fs0 := make([]ydb.StructOption, 2)
						var t3 ydb.Type
						{
							tp0 := ydb.TypeFloat
							t3 = tp0
						}
						fs0[0] = ydb.StructField("x", t3)
						var t4 ydb.Type
						{
							tp0 := ydb.TypeFloat
							t4 = tp0
						}
						fs0[1] = ydb.StructField("y", t4)
						t2 = ydb.Struct(fs0...)
					}
					t1 = t2
				}
				t0 := ydb.List(t1)
				list0 = ydb.ZeroValue(t0)
			} else {
				list0 = ydb.ListValue(vs0...)
			}
			v2 = list0
		}
		v0 = ydb.StructValue(
			ydb.StructFieldValue("fig_place", v1),
			ydb.StructFieldValue("points", v2),
		)
	}
	return v0
}

func (f *Figure) StructType() ydb.Type {
	var t0 ydb.Type
	{
		fs0 := make([]ydb.StructOption, 2)
		var t1 ydb.Type
		{
			var t2 ydb.Type
			{
				fs1 := make([]ydb.StructOption, 1)
				var t3 ydb.Type
				{
					var t4 ydb.Type
					{
						fs2 := make([]ydb.StructOption, 2)
						var t5 ydb.Type
						{
							tp0 := ydb.TypeFloat
							t5 = tp0
						}
						fs2[0] = ydb.StructField("x", t5)
						var t6 ydb.Type
						{
							tp0 := ydb.TypeFloat
							t6 = tp0
						}
						fs2[1] = ydb.StructField("y", t6)
						t4 = ydb.Struct(fs2...)
					}
					t3 = t4
				}
				fs1[0] = ydb.StructField("fig_place", t3)
				t2 = ydb.Struct(fs1...)
			}
			t1 = t2
		}
		fs0[0] = ydb.StructField("fig_place", t1)
		var t2 ydb.Type
		{
			var t4 ydb.Type
			{
				var t5 ydb.Type
				{
					fs1 := make([]ydb.StructOption, 2)
					var t6 ydb.Type
					{
						tp0 := ydb.TypeFloat
						t6 = tp0
					}
					fs1[0] = ydb.StructField("x", t6)
					var t7 ydb.Type
					{
						tp0 := ydb.TypeFloat
						t7 = tp0
					}
					fs1[1] = ydb.StructField("y", t7)
					t5 = ydb.Struct(fs1...)
				}
				t4 = t5
			}
			t3 := ydb.List(t4)
			t2 = t3
		}
		fs0[1] = ydb.StructField("points", t2)
		t0 = ydb.Struct(fs0...)
	}
	return t0
}

func (ps *Points) Scan(res *table.Result) (err error) {
	for res.NextRow() {
		var x0 Point
		res.SeekItem("x")
		x0.x = float64(res.Float())

		res.SeekItem("y")
		x0.y = float64(res.Float())

		if res.Err() == nil {
			*ps = append(*ps, x0)
		}
	}
	return res.Err()
}

func ydbConvU32ToB(x uint32) byte {
	const (
		bits = 8
		mask = (1 << (bits)) - 1
	)
	abs := uint64(x)
	if abs&mask != abs {
		panic(
			"ydbgen: convassert: " + strconv.FormatUint(uint64(x), 10) +
				" (type uint32) overflows byte",
		)
	}
	return byte(x)
}

`,
		},
		{
			name: "unknown struct",
			in: `package tests
//ydb:generate
type WrongStruct struct {
	Struct  F
	Bytes   []byte <backtick>ydb:"type:list<uint32>,conv:assert"<backtick>
	Strings []string <backtick>ydb:"type:list<string>"<backtick>
	String  []byte
}`,
			correct: false,
		},
		{
			name: "unknown pointer",
			in: `package tests
//ydb:generate
type WrongStructPointer struct {
	Struct  *Point
	Bytes   []byte <backtick>ydb:"type:list<uint32>,conv:assert"<backtick>
	Strings []string <backtick>ydb:"type:list<string>"<backtick>
	String  []byte
}`,
			correct: false,
		},
		{
			name: "unknown slice",
			in: `package tests
//ydb:generate
type WrongStructSlice struct {
	Struct  []Slice
	Bytes   []byte <backtick>ydb:"type:list<uint32>,conv:assert"<backtick>
	Strings []string <backtick>ydb:"type:list<string>"<backtick>
	String  []byte
}`,
			correct: false,
		},
		{
			name: "non-supported interface type",
			in: `package tests
//ydb:generate
type StructInterface struct {
	Struct  []interface{} <backtick>ydb:"type:list<uint32>,conv:assert"<backtick>
	Bytes   []byte <backtick>ydb:"type:list<uint32>,conv:assert"<backtick>
	Strings []string <backtick>ydb:"type:list<string>"<backtick>
	String  []byte
}`,
			correct: false,
		},
		{
			name: "non-supported struct type",
			in: `package tests
//ydb:generate
type AnonymousStruct {
	Struct  struct{}
	Bytes   []byte <backtick>ydb:"type:list<uint32>,conv:assert"<backtick>
	Strings []string <backtick>ydb:"type:list<string>"<backtick>
	String  []byte
}`,
			correct: false,
		},
		{
			name: "non-supported pointer",
			in: `package tests
//ydb:generate
type PointerStruct {
Str   *string +  <backtick>ydb:"type:string?"<backtick>
		}`,
			correct: false,
		},
		{
			name: "wrong tag list for type string",
			in: `package tests
//ydb:generate
type WrongStringStruct struct {
	WrongTagString string <backtick>ydb:"type:list<string>"<backtick>
	Bytes   []byte   <backtick>ydb:"type:list<uint32>,conv:assert"<backtick>
	Strings []string <backtick>ydb:"type:list<string>"<backtick>
	String  []byte
}`,
			correct: false,
		},
		{
			name: "wrong tag string for type int",
			in: `package tests
//ydb:generate
type WrongIntStruct struct {
	WrongTagInt int32 <backtick>ydb:"type:string"<backtick>
	Bytes   []byte   <backtick>ydb:"type:list<uint32>,conv:assert"<backtick>
	Strings []string <backtick>ydb:"type:list<string>"<backtick>
	String  []byte
}`,
			correct: false,
		},
		{
			name: "incorrect format of multiple tags",
			in: `package tests
//ydb:generate
type MultipleIncorrectTags struct {
	a int <backtick>ydb:"type:int32",json:"a"<backtick>
	b int <backtick>ydb:"type:int64",json:"b"<backtick>
}
`,
			correct: false,
		},
		{
			name: "multiple tags",
			in: `package tests
//ydb:generate
type MultipleTags struct {
	a int32 <backtick>ydb:"type:int32" json:"a"<backtick>
	b int64 <backtick>ydb:"type:int64" json:"b"<backtick>
}`,
			correct: true,
			out: `// Code generated by ydbgen; DO NOT EDIT.

package tests

import (
	"strconv"

	ydb "github.com/YandexDatabase/ydb-go-sdk/v2"
	"github.com/YandexDatabase/ydb-go-sdk/v2/table"
)

var (
	_ = strconv.Itoa
	_ = ydb.StringValue
	_ = table.NewQueryParameters
)

func (m *MultipleTags) Scan(res *table.Result) (err error) {
	res.SeekItem("a")
	m.a = res.Int32()

	res.SeekItem("b")
	m.b = res.Int64()

	return res.Err()
}

func (m *MultipleTags) QueryParameters() *table.QueryParameters {
	var v0 ydb.Value
	{
		vp0 := ydb.Int32Value(m.a)
		v0 = vp0
	}
	var v1 ydb.Value
	{
		vp0 := ydb.Int64Value(m.b)
		v1 = vp0
	}
	return table.NewQueryParameters(
		table.ValueParam("$a", v0),
		table.ValueParam("$b", v1),
	)
}

func (m *MultipleTags) StructValue() ydb.Value {
	var v0 ydb.Value
	{
		var v1 ydb.Value
		{
			vp0 := ydb.Int32Value(m.a)
			v1 = vp0
		}
		var v2 ydb.Value
		{
			vp0 := ydb.Int64Value(m.b)
			v2 = vp0
		}
		v0 = ydb.StructValue(
			ydb.StructFieldValue("a", v1),
			ydb.StructFieldValue("b", v2),
		)
	}
	return v0
}

func (m *MultipleTags) StructType() ydb.Type {
	var t0 ydb.Type
	{
		fs0 := make([]ydb.StructOption, 2)
		var t1 ydb.Type
		{
			tp0 := ydb.TypeInt32
			t1 = tp0
		}
		fs0[0] = ydb.StructField("a", t1)
		var t2 ydb.Type
		{
			tp0 := ydb.TypeInt64
			t2 = tp0
		}
		fs0[1] = ydb.StructField("b", t2)
		t0 = ydb.Struct(fs0...)
	}
	return t0
}

`,
		},
		{
			name: "test date",
			in: `package tests
import "time"
//ydb:gen
type Times struct {
	Date time.Time <backtick>ydb:"type:Date?"<backtick>
}
`,
			correct: true,
			out: `// Code generated by ydbgen; DO NOT EDIT.

package tests

import (
	"strconv"

	ydb "github.com/YandexDatabase/ydb-go-sdk/v2"
	"github.com/YandexDatabase/ydb-go-sdk/v2/table"
)

var (
	_ = strconv.Itoa
	_ = ydb.StringValue
	_ = table.NewQueryParameters
)

func (t *Times) Scan(res *table.Result) (err error) {
	res.SeekItem("date")
	res.Unwrap()
	if !res.IsNull() {
		x0 := res.Date()
		err := (*ydb.Time)(&t.Date).FromDate(x0)
		if err != nil {
			panic("ydbgen: date type conversion failed: " + err.Error())
		}
	}

	return res.Err()
}

func (t *Times) QueryParameters() *table.QueryParameters {
	var v0 ydb.Value
	{
		var v1 ydb.Value
		var x0 uint32
		ok0 := !t.Date.IsZero()
		if ok0 {
			x0 = ydb.Time(t.Date).Date()
		}
		if ok0 {
			v1 = ydb.OptionalValue(ydb.DateValue(x0))
		} else {
			v1 = ydb.NullValue(ydb.TypeDate)
		}
		v0 = v1
	}
	return table.NewQueryParameters(
		table.ValueParam("$date", v0),
	)
}

func (t *Times) StructValue() ydb.Value {
	var v0 ydb.Value
	{
		var v1 ydb.Value
		{
			var v2 ydb.Value
			var x0 uint32
			ok0 := !t.Date.IsZero()
			if ok0 {
				x0 = ydb.Time(t.Date).Date()
			}
			if ok0 {
				v2 = ydb.OptionalValue(ydb.DateValue(x0))
			} else {
				v2 = ydb.NullValue(ydb.TypeDate)
			}
			v1 = v2
		}
		v0 = ydb.StructValue(
			ydb.StructFieldValue("date", v1),
		)
	}
	return v0
}

func (t *Times) StructType() ydb.Type {
	var t0 ydb.Type
	{
		fs0 := make([]ydb.StructOption, 1)
		var t1 ydb.Type
		{
			tp0 := ydb.TypeDate
			t1 = ydb.Optional(tp0)
		}
		fs0[0] = ydb.StructField("date", t1)
		t0 = ydb.Struct(fs0...)
	}
	return t0
}

`,
		},
		{
			name: "convert test",
			in: `package tests
//ydb:generate
type ConvertType struct {
	Field uint32 <backtick>ydb:"type:int32,conv:unsafe"<backtick>
	Field2 int32 <backtick>ydb:"type:uint32,conv:unsafe"<backtick>
}
`,
			correct: true,
			out: `// Code generated by ydbgen; DO NOT EDIT.

package tests

import (
	"strconv"

	ydb "github.com/YandexDatabase/ydb-go-sdk/v2"
	"github.com/YandexDatabase/ydb-go-sdk/v2/table"
)

var (
	_ = strconv.Itoa
	_ = ydb.StringValue
	_ = table.NewQueryParameters
)

func (c *ConvertType) Scan(res *table.Result) (err error) {
	res.SeekItem("field")
	c.Field = uint32(res.Int32())

	res.SeekItem("field2")
	c.Field2 = int32(res.Uint32())

	return res.Err()
}

func (c *ConvertType) QueryParameters() *table.QueryParameters {
	var v0 ydb.Value
	{
		vp0 := ydb.Int32Value(int32(c.Field))
		v0 = vp0
	}
	var v1 ydb.Value
	{
		vp0 := ydb.Uint32Value(uint32(c.Field2))
		v1 = vp0
	}
	return table.NewQueryParameters(
		table.ValueParam("$field", v0),
		table.ValueParam("$field2", v1),
	)
}

func (c *ConvertType) StructValue() ydb.Value {
	var v0 ydb.Value
	{
		var v1 ydb.Value
		{
			vp0 := ydb.Int32Value(int32(c.Field))
			v1 = vp0
		}
		var v2 ydb.Value
		{
			vp0 := ydb.Uint32Value(uint32(c.Field2))
			v2 = vp0
		}
		v0 = ydb.StructValue(
			ydb.StructFieldValue("field", v1),
			ydb.StructFieldValue("field2", v2),
		)
	}
	return v0
}

func (c *ConvertType) StructType() ydb.Type {
	var t0 ydb.Type
	{
		fs0 := make([]ydb.StructOption, 2)
		var t1 ydb.Type
		{
			tp0 := ydb.TypeInt32
			t1 = tp0
		}
		fs0[0] = ydb.StructField("field", t1)
		var t2 ydb.Type
		{
			tp0 := ydb.TypeUint32
			t2 = tp0
		}
		fs0[1] = ydb.StructField("field2", t2)
		t0 = ydb.Struct(fs0...)
	}
	return t0
}

`,
		},
		{
			name: "check primitive",
			in: `package tests
//ydb:generate
type Primitive []uint32
`,
			correct: true,
			out: `// Code generated by ydbgen; DO NOT EDIT.

package tests

import (
	"strconv"

	ydb "github.com/YandexDatabase/ydb-go-sdk/v2"
	"github.com/YandexDatabase/ydb-go-sdk/v2/table"
)

var (
	_ = strconv.Itoa
	_ = ydb.StringValue
	_ = table.NewQueryParameters
)

func (ps *Primitive) Scan(res *table.Result) (err error) {
	for res.NextRow() {
		var x0 uint32
		x0 = res.Uint32()
		if res.Err() == nil {
			*ps = append(*ps, x0)
		}
	}
	return res.Err()
}

func (Primitive) ListType() ydb.Type {
	var t1 ydb.Type
	{
		tp0 := ydb.TypeUint32
		t1 = tp0
	}
	t0 := ydb.List(t1)
	return t0
}

func (ps Primitive) ListValue() ydb.Value {
	var list0 ydb.Value
	vs0 := make([]ydb.Value, len(ps))
	for i0, item0 := range ps {
		var v0 ydb.Value
		{
			vp0 := ydb.Uint32Value(item0)
			v0 = vp0
		}
		vs0[i0] = v0
	}
	if len(vs0) == 0 {
		var t1 ydb.Type
		{
			tp0 := ydb.TypeUint32
			t1 = tp0
		}
		t0 := ydb.List(t1)
		list0 = ydb.ZeroValue(t0)
	} else {
		list0 = ydb.ListValue(vs0...)
	}
	return list0
}

`,
		},
		{
			name: "Set optional",
			in: `package tests
//ydb:set wrap:optional
//ydb:generate
type SetOptional struct {
	optField int32
}
`,
			correct: true,
			out: `// Code generated by ydbgen; DO NOT EDIT.

package tests

import (
	"strconv"

	ydb "github.com/YandexDatabase/ydb-go-sdk/v2"
	"github.com/YandexDatabase/ydb-go-sdk/v2/table"
)

var (
	_ = strconv.Itoa
	_ = ydb.StringValue
	_ = table.NewQueryParameters
)

func (s *SetOptional) Scan(res *table.Result) (err error) {
	res.SeekItem("opt_field")
	s.optField = res.OInt32()

	return res.Err()
}

func (s *SetOptional) QueryParameters() *table.QueryParameters {
	var v0 ydb.Value
	{
		vp0 := ydb.OptionalValue(ydb.Int32Value(s.optField))
		v0 = vp0
	}
	return table.NewQueryParameters(
		table.ValueParam("$opt_field", v0),
	)
}

func (s *SetOptional) StructValue() ydb.Value {
	var v0 ydb.Value
	{
		var v1 ydb.Value
		{
			vp0 := ydb.OptionalValue(ydb.Int32Value(s.optField))
			v1 = vp0
		}
		v0 = ydb.StructValue(
			ydb.StructFieldValue("opt_field", v1),
		)
	}
	return v0
}

func (s *SetOptional) StructType() ydb.Type {
	var t0 ydb.Type
	{
		fs0 := make([]ydb.StructOption, 1)
		var t1 ydb.Type
		{
			tp0 := ydb.TypeInt32
			t1 = ydb.Optional(tp0)
		}
		fs0[0] = ydb.StructField("opt_field", t1)
		t0 = ydb.Struct(fs0...)
	}
	return t0
}

`,
		},
		{
			name: "check get set",
			in: `package tests
//ydb:generate
type GetterSetter struct {
	GetSetField GetterSetterField
}
//ydb:generate scan
type GetterSetterField struct {
	a       int32
	defined bool
}
func (g *GetterSetterField) Set(val int32) {
	g.a = val
	g.defined = true
}
func (g GetterSetterField) Get() (int32, bool) {
	return g.a, g.defined
}
`,
			correct: true,
			out: `// Code generated by ydbgen; DO NOT EDIT.

package tests

import (
	"strconv"

	ydb "github.com/YandexDatabase/ydb-go-sdk/v2"
	"github.com/YandexDatabase/ydb-go-sdk/v2/table"
)

var (
	_ = strconv.Itoa
	_ = ydb.StringValue
	_ = table.NewQueryParameters
)

func (g *GetterSetter) Scan(res *table.Result) (err error) {
	res.SeekItem("get_set_field")
	res.Unwrap()
	if !res.IsNull() {
		x0 := res.Int32()
		g.GetSetField.Set(x0)
	}

	return res.Err()
}

func (g *GetterSetter) QueryParameters() *table.QueryParameters {
	var v0 ydb.Value
	{
		var v1 ydb.Value
		x0, ok0 := g.GetSetField.Get()
		if ok0 {
			v1 = ydb.OptionalValue(ydb.Int32Value(x0))
		} else {
			v1 = ydb.NullValue(ydb.TypeInt32)
		}
		v0 = v1
	}
	return table.NewQueryParameters(
		table.ValueParam("$get_set_field", v0),
	)
}

func (g *GetterSetter) StructValue() ydb.Value {
	var v0 ydb.Value
	{
		var v1 ydb.Value
		{
			var v2 ydb.Value
			x0, ok0 := g.GetSetField.Get()
			if ok0 {
				v2 = ydb.OptionalValue(ydb.Int32Value(x0))
			} else {
				v2 = ydb.NullValue(ydb.TypeInt32)
			}
			v1 = v2
		}
		v0 = ydb.StructValue(
			ydb.StructFieldValue("get_set_field", v1),
		)
	}
	return v0
}

func (g *GetterSetter) StructType() ydb.Type {
	var t0 ydb.Type
	{
		fs0 := make([]ydb.StructOption, 1)
		var t1 ydb.Type
		{
			tp0 := ydb.TypeInt32
			t1 = ydb.Optional(tp0)
		}
		fs0[0] = ydb.StructField("get_set_field", t1)
		t0 = ydb.Struct(fs0...)
	}
	return t0
}

func (g *GetterSetterField) Scan(res *table.Result) (err error) {
	res.SeekItem("a")
	g.a = res.OInt32()

	res.SeekItem("defined")
	g.defined = res.OBool()

	return res.Err()
}

`,
		},
	}
)
